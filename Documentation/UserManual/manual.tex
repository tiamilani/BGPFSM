\documentclass[10pt,journal,onecolumn]{IEEEtran}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{silence}\WarningsOff[latexfont]

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

\usepackage{graphicx}
\graphicspath{images/}
\usepackage{cite}
\usepackage{url}
\usepackage{subcaption}
\usepackage{float}
\usepackage[ruled,vlined,linesnumbered]{algorithm2e}
\SetKwProg{Fn}{Event}{}{}
\SetKw{And}{and}
\usepackage[binary-units,per-mode=symbol]{siunitx}
\sisetup{list-final-separator = {, and },detect-weight=true, detect-family=true}
\usepackage{booktabs}
\usepackage{pifont}
\usepackage{microtype}
\usepackage{textcomp}
\usepackage[american]{babel}
\usepackage[capitalise]{cleveref}
\def\figname{\csname cref@figure@name\endcsname\xspace}
\def\tabname{\csname cref@table@name\endcsname\xspace}
\def\secname{\csname cref@section@name\endcsname\xspace}
\def\eqpname{\csname cref@equation@name@plural\endcsname\xspace}
\crefname{algorithm}{Listing}{Lists.}
\Crefname{algorithm}{Listing}{Listings}
\SetAlgorithmName{Listing}{Listing}{List of Listings}
\crefname{lstlisting}{listing}{listings}
\Crefname{lstlisting}{Listing}{Listings}
\usepackage{xspace}
\usepackage{hyphenat}
\usepackage[draft,inline,nomargin,index]{fixme}
\fxsetup{theme=color}
\usepackage{grffile}
\usepackage{xfrac}
\usepackage{multirow}
%\usepackage[para]{footmisc}
\usepackage[font={small}]{caption}
\usepackage{imakeidx}
\usepackage{longtable}
\usepackage[table]{xcolor}
\definecolor{lightgray}{gray}{0.9}
\let\oldlongtable\longtable

\let\endoldlongtable\endlongtable

\renewenvironment{longtable}{\rowcolors{2}{white}{lightgray}\oldlongtable} 
{\endoldlongtable}

\usepackage{tikz}
\usetikzlibrary{calc,shapes,arrows,fit,positioning}

\usepackage{listings}
\lstset{
   language=sh,
   columns=fixed,
   breaklines=true,
   breakatwhitespace=true,
   prebreak=\textbackslash,
   basicstyle=\ttfamily\small,
   showstringspaces=false,
   upquote=true,
   keywordstyle=\ttfamily\small
}

\usepackage{color}
\definecolor{gray}{rgb}{0.4,0.4,0.4}
\definecolor{darkblue}{rgb}{0.0,0.0,0.6}
\definecolor{cyan}{rgb}{0.0,0.6,0.6}


\lstdefinelanguage{XML}
{
  morestring=[b]",
  morestring=[s]{>}{<},
  morecomment=[s]{<?}{?>},
  stringstyle=\color{black},
  identifierstyle=\color{darkblue},
  keywordstyle=\color{cyan},
  morekeywords={xmlns,version,type}% list your attributes here
}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{shell}{
    backgroundcolor=\color{backcolour},
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstdefinestyle{graphml}{
    backgroundcolor=\color{backcolour},
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstMakeShortInline[language=bash]|

% fix cleveref and breqn
\makeatletter
\let\cref@old@eq@setnumberOld\eq@setnumber
\def\eq@setnumber{%
\cref@old@eq@setnumberOld%
\cref@constructprefix{equation}{\cref@result}%
\protected@xdef\cref@currentlabel{%
[equation][\arabic{equation}][\cref@result]\p@equation\eq@number}}
\makeatother

% reduce verbatim font size
\usepackage{etoolbox}
\makeatletter
\patchcmd{\@verbatim}
  %%%{\verbatim@font} %% blow up TexMaker formatting ???!!! 
  {\verbatim@font\small}
  {}{}
\makeatother

\RequirePackage{xstring}
\RequirePackage{xparse}
\RequirePackage[index=true]{acro}
\NewDocumentCommand\acrodef{mO{#1}mG{}}{\DeclareAcronym{#1}{short={#2}, long={#3}, #4}}
\NewDocumentCommand\acused{m}{\acuse{#1}}


\acrodef{ADV}{advertisement}
\acrodef{AS}{Autonomous System}{short-plural=es}
\acrodef{BGP}{Border Gateway Protocol}
\acrodef{BIRD}{BGP Internet Routing Daemon}
\acrodef{DPC}{Destination Partial Centrality}
\acrodef{eBGP}{Exterior BGP}
\acrodef{ERP}{Exterior Routing Protocol}
\acrodef{IoF}{Internet on FIRE}
\acrodef{IP}{Internet Protocol}
\acrodef{MRAI}{Minimum Route Advertisement Interval}
\acrodef{NH}{Next Hop}
\acrodef{RFC}{Request For Comment} 
\acrodef{TCP}{Transmission Control Protocol}
\acrodef{FSM}{Finite State Machine}
\acrodef{DES}{Descrete Event Simulator}
\acrodef{RFD}{Route Flap Damping}
\acrodef{RNG}{Random Number Generator}
\acrodef{LID}{Link identifier}
\acrodef{RIB}{Routing Information Base}{short-plural=s}

\newcommand\useallac{
\acused{IP}
\acused{TCP}
\acused{RFC}
}

\useallac

\newcommand{\figwidthfour}{0.78}
\newcommand{\figwidth}{0.78}
\newcommand{\figvspace}{-1.5em}
\newcommand{\update}{\texttt{UPDATE}\xspace}
\newcommand{\nodeset}{\ensuremath{\mathcal{V}}\xspace}
\newcommand{\destinationset}{\ensuremath{\mathcal{C}}\xspace}
\newcommand{\edgeset}{\ensuremath{\mathcal{E}}\xspace}
\newcommand{\graph}{\ensuremath{\mathcal{G(\nodeset,\edgeset)}}\xspace}
\newcommand{\pathset}{\ensuremath{\mathcal{C}}\xspace}
\newcommand{\ascentg}{\ensuremath{\mathcal{G_{A}}\xspace}}
\newcommand{\ascentnodeset}{\ensuremath{\mathcal{V^{\ascentg}}}\xspace}
\newcommand{\ascentedgeset}{\ensuremath{\mathcal{E^{\ascentg}}}\xspace}
\newcommand{\ascentgraph}{\ensuremath{\mathcal{\ascentg(\ascentnodeset,\ascentedgeset)}}\xspace}
\newcommand{\dpc}{\ensuremath{\Delta}\xspace}
\newcommand{\tr}{\ensuremath{T_{R}}\xspace}

\newcommand{\tierg}{\ensuremath{\mathcal{G_{T}}\xspace}}
\newcommand{\tiernodeset}{\ensuremath{\mathcal{V^{\tierg}}}\xspace}
\newcommand{\tieredgeset}{\ensuremath{\mathcal{E^{\tierg}}}\xspace}
\newcommand{\tiergraph}{\ensuremath{\mathcal{\tierg(\tiernodeset,\tieredgeset)}}\xspace}
\newcommand{\descentg}{\ensuremath{\mathcal{G_{D}}\xspace}}
\newcommand{\descentnodeset}{\ensuremath{\mathcal{V^{\descentg}}}\xspace}
\newcommand{\descentedgeset}{\ensuremath{\mathcal{E^{\descentg}}}\xspace}
\newcommand{\descentgraph}{\ensuremath{\mathcal{\descentg(\descentnodeset,\descentedgeset)}}\xspace}

\IEEEoverridecommandlockouts
\makeindex[columns=3, title=Alphabetical Index, intoc]

\begin{document}

\title{User Manual BGP simulator}
\author{
	\IEEEauthorblockN{Mattia Milani}\\
    \IEEEauthorblockA{Dept. of Information Engineering and Computer Science, University of Trento, Italy}
    \texttt{mattia.milani@studenti.unitn.it}
}


\maketitle

\clearpage

\tableofcontents

\clearpage

\section{Guide environment}
\label{sec:guide_environment}

This guide has been tested on a clean installation of ubuntu 18.04
with python 3.6.9

\section{Experiments general chain}
\label{sec:general_chain}

This environment is composed by different components, thats executed one after
the other will produce the output expected.

\begin{figure}[h]
	\begin{center}
		\begin{tikzpicture}[scale=0.2]
			\tikzstyle{every node}+=[inner sep=0pt]
			\draw [black] (0,0) rectangle (10,5);
			\draw [black] (20,0) rectangle (30,5);
			\draw [black] (40,0) rectangle (50,5);
			\draw [thick, ->] (10,2.5) -- (20,2.5);
			\draw [thick, ->] (30,2.5) -- (40,2.5);
			\node [DES] at (5,2.5) {DES};
			\node [Analyzer] at (25,2.5) {Analyzer};
			\node [Plotter] at (45,2.5) {Plotter};
		\end{tikzpicture}
	\end{center}
	\caption{General environment chain}
	\label{fig:general_chain}
\end{figure}

\Cref{fig:general_chain} shows how in general an experiment is conducted.
The first step is the \ac{DES} that takes in input some configuration files
and runs each step of the simulation.
The network simulated evolves producting some output files in \textit{CSV} format
that would be the input for the next step.
The second part of this environment is take by the analyzer, it's the main
interpreter of the \ac{DES} output, it takes as input the CSVs files produced
by the first step. The output of the analyzer is another set of CSVs that are
easily plottable or that represent in a more clean way some aspectes of the simulations.
The analyzer can take as input multiple \ac{DES} execution and produce mean
results.
The analyzer is a necessary step to merge multiple experiments, it is also
necessary because from a single \ac{DES} execution is possible to study
a lot of different aspects (Time convergence, number of messages, a single node
evolution, etc.) and is not always necessary to study all this aspects.
The last part of an experiment is the plotter.
This part take as input CSV files created by the analyzer and simply plot what
is in them.

Each component is necessary to reach the goal of an experiment.

\section{How to install}
\label{sec:installation}

This section contains an explanation on how to install in the correct
way the software required by the environment.

In the main src folder of the project is present a bash file that will install
everything you need, just use the following commands:

\lstset{style=shell}
\begin{lstlisting}[language=bash]
	cd src/
	./install.sh
\end{lstlisting}

This code will execute the default installation process, is possible to modify the default
values using the install script arguments.

use: 
\begin{lstlisting}[language=bash]
	./install.sh -h
\end{lstlisting}
to see the argument description.

The installation script will automatically install the following packets:
\begin{itemize}
		\item python-virtualenv, permits the use of python virtual environment,
			used to create the environment where all the python libraries and packages
			will be installed
		\item parallel, permits the execution of parallel commands/scripts and
			a lot more things, used to run multiple experiments in parallel
		\item graphviz, used to produce some graphs after the analysis part.
		\item gcc, required by the pygraphviz package
		\item python3-dev, required by some packages installed
\end{itemize}
The installation script will also create a virtual env for the python packages
required and then install all the python packages necessary.
use:
\begin{lstlisting}[language=bash]
	./install.sh -n <env-name>
\end{lstlisting}
to redefine the virtual environment default name (env).
The second argument that is possible to pass to the installation script is
the position of the python interpreter.
The default is the output of the command |which python3|, is possible to modify
it with:
\begin{lstlisting}[language=bash]
	./install.sh -p <path-to-python-interpreter>
\end{lstlisting}

The suggested python interpreter is the version 3.6.9, the one that has been tested.

The list of python packages that will be installed is contained in the file
|requirements.txt|.

At the end of the installation will be possible to use the virtual environment
just created, use the following command to activate the virtual environment:
\begin{lstlisting}[language=bash]
	source /<env-name>/bin/activate
\end{lstlisting}
To deactivate an environment use the command:
\begin{lstlisting}[language=bash]
	deactivate
\end{lstlisting}

For compatibilities problems with libraries versions and python versions
please contact me.

\section{Experiments configuration files}
\label{sec:exp_conf}

To execute an experiment are necessary some configuration files that define how
the environment is setted and generated.
For example is possible to define which nodes are in the network and the connections
between one another, then is possible to configure the single node properties.
Another configuration file permits to configure the general properties of the
experiment, for example: the signal that the source nodes should share, the 
maximum experiment duration ecc.

All this parameters are divided in two files that are here presented.
The approach to those files in this document is the following:
in the \Cref{subsec:graph_file,subsec:json_file} all the configuration properties
are presented.
in the following sections all these properties are displayed in an 
increasingly complete way until you see each of them.
Some of them are not compatible one another.

\subsection{Graph file}
\label{subsec:graph_file}

The graph file is the one that describes the network. though it is possible
to define the nodes of the experiment and te relation between one another.
The format chosen for this file is the graphml format, that gives enough liberty
to define all the topological properties of the network.

The common structure of the graphml file is the following:
% TODO color the main arguments
\begin{lstlisting}[language=bash]
	<?xml version='1.0' encoding='utf-8'?>
	<graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://graphml.graphdr    awing.org/xmlns http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">
	  <attributes/>
	  <graph edgedefault="directed">
		< nodes section />
	    <node id="0">
			< node attributes />
	    </node>
		< edges section />
	    <edge source="0" target="1">
			< edge attributes />
	    </edge>
	  </graph>
	</graphml> 
\end{lstlisting}

an example of simple graph is given by the following graphml code:
\lstset{style=graphml}
\renewcommand{\lstlistingname}{Conf file}
\begin{lstlisting}[language=bash, caption=first graph file, label=graph:first_graphml]
	<?xml version='1.0' encoding='utf-8'?>
	<graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://graphml.graphdr    awing.org/xmlns http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">
	  <key attr.name="destinations" attr.type="string" for="node" id="d0" />
	  <key attr.name="delay" attr.type="string" for="edge" id="d1" />
	  <graph edgedefault="directed">
	    <node id="0">
	        <data key="d0">10.0.0.0/24,10.0.1.0/24</data>
	    </node>
	    <node id="1">
	        <data key="d0">10.0.2.0/24,10.0.3.0/24</data>
	    </node>
	    <node id="2">
	    </node>
	    <node id="3">
	    </node>
	    <edge source="0" target="1">
	        <data key="d1">{"distribution": "unif", "min": 1, "max": 5, "int": 0.01}</data>
	    </edge>
	    <edge source="0" target="3">
	    </edge>
	    <edge source="1" target="0">
	    </edge>
	    <edge source="1" target="2">
	    </edge>
	    <edge source="2" target="1">
	    </edge>
	    <edge source="1" target="3">
	    </edge>
	    <edge source="3" target="1">
	    </edge>
	  </graph>
	</graphml>
\end{lstlisting}

that represent the following graph:
\begin{figure}[h]
	\begin{center}
		\begin{tikzpicture}[scale=0.2]
			\tikzstyle{every node}+=[inner sep=0pt]
			\draw [black] (24.9,-18.3) circle (3);
			\draw (24.9,-18.3) node {$0$};
			\draw [black] (43.6,-18.3) circle (3);
			\draw (43.6,-18.3) node {$1$};
			\draw [black] (43.6,-3.8) circle (3);
			\draw (43.6,-3.8) node {$2$};
			\draw [black] (43.6,-31.9) circle (3);
			\draw (43.6,-31.9) node {$3$};
			\draw [black] (27.9,-18.3) -- (40.6,-18.3);
			\fill [black] (40.6,-18.3) -- (39.8,-17.8) -- (39.8,-18.8);
			\draw (34.25,-17.8) node [above] {$delay$};
			\draw [black] (27.33,-20.06) -- (41.17,-30.14);
			\fill [black] (41.17,-30.14) -- (40.82,-29.26) -- (40.23,-30.07);
			\draw [black] (40.6,-18.3) -- (27.9,-18.3);
			\fill [black] (27.9,-18.3) -- (28.7,-18.8) -- (28.7,-17.8);
			\draw [black] (43.6,-15.3) -- (43.6,-6.8);
			\fill [black] (43.6,-6.8) -- (43.1,-7.6) -- (44.1,-7.6);
			\draw [black] (43.6,-6.8) -- (43.6,-15.3);
			\fill [black] (43.6,-15.3) -- (44.1,-14.5) -- (43.1,-14.5);
			\draw [black] (43.6,-21.3) -- (43.6,-28.9);
			\fill [black] (43.6,-28.9) -- (44.1,-28.1) -- (43.1,-28.1);
			\draw [black] (43.6,-28.9) -- (43.6,-21.3);
			\fill [black] (43.6,-21.3) -- (43.1,-22.1) -- (44.1,-22.1);
		\end{tikzpicture}
	\end{center}
	\caption{Graphml graphical representation}
	\label{fig:first_graph_representation}
\end{figure}

As we can notice in graphml file \ref{graph:first_graphml} nodes \num{0} and \num{1} uses the attribute $d0$ that
defines a property of them (all the properties are listed below).
In the edges section is alto noticable that a delay attribute is used between
node \num{0} and \num{1}.

The graph must be directed

All the accepted properties for nodes are listed below:
\begin{itemize}
		\item destinations:  This attribute represent the networks that a node will share 
			during the experiment, it is possible to intrudce multiple networs 
			separated by a |,|;
		\item MRAI\_affects\_withdraws: This attribute defines if the node does not 
			applys the suggested RFC \fixme{insert citation} where is defined that
			MRAI does not affect withdraws, insert a value higher than \num{0} to
			activate this function;
		\item RFD: Route flap damping, this attribute defines the parameters
			that the node will use to configure its own route flap dampening
			procedure;
		\item centrality: Float value that defines the centrality of the node;
		\item type: String attribute that defines the type of the node.
\end{itemize}
The type of a node could be one from the following:
\begin{itemize}
		\item T: tier one node;
		\item M: Nodes that act as proveders for clients;
		\item CP: Client providers nodes;
		\item C: Client nodes.
\end{itemize}
The \ac{RFD} configuration parameters are described in \Cref{subsec:RFD}.

All the accepted properties for edges are listed below:
\begin{itemize}
		\item delay: {distribution} is possible to introduce a delay distribution 
			for a single edge, the distribution has to respect what said in the 
			distribution section of the readme. This parameter will override the 
			json delay parameter for the edge;
		\item policy: is possible to define a policy function for every single edge, 
			policy functions are applyied like explanied in \fixme{insert citation} 
			see the section policy function for more deep explanations, default: pass everything;
		\item mrai: is possible to define an \ac{MRAI} value for each edge, this 
			float value would override the default one of
			30.0 seconds, like defined in \fixme{citation rfc 4271}.
\end{itemize}

Refers respecively to \Cref{subsec:distribution,subsec:policies} for an explanation
about distributions that can be used and how policies can be setted.

Examples of complex graphs are contained in the |graphs| folder and some of them
are exmplained in the next chapters.

\subsection{Json file}
\label{subsec:json_file}

To define environment variables is possible to use a json file that must be 
passed to the DES. 
Examples of configuration file is available in: |/src/json/|

The parameters that can be defined inside the json file are:
\begin{itemize}
    \item seed: this variable represents the seed that will be passed to 
		the \ac{RNG} at the environment initialization
    \item duration: Duration of each run in seconds
    \item graph: Graphml file that will be used for all the runs
    \item output: Represent the output file of each run. is possible to use 
		other variables inside the string, for example |{date-time}| will be 
		substituted by the actual dateTime of the experiment (up to ms) or 
		is possible to use other variables like |{seed}| or |{withdraw_dist.min}|
		to introduce more levels of details to recognize the output csv 
		file among many of a multi run script
    \item verbose: |[True/False]| variable, if true the experiment will 
		print the evolution on standard output
	\item signaling: |[True/False]| variable, if true the experiment will use 
		the signaling sequence defined in |signaling_sequence|, nodes that contains
		a destination will respect this sequence using the withdraw and reannouncement
		distribution.
		If false the evolution will be based on the \ac{RNG} and limited only
		by the |duration|.
	\item signaling\_sequence: |"AWAW..."| string variable composed by a 
		sequence of announcements and withdraws, this will be the execution sequence
		for nodes that share a destination.
	\item implicit\_withdraw: |[True/False]| variable, if True nodes will 
		use the implicit withdraw schema (a new path for a neighbour is the sum
		of a withdraw of the previous path and the announcement of the new 
		best path) if false nodes that change best path will send a withdraw 
		followed by an announcement.
    \item withdraw: |[True/False]| variable, if true a node that previusly 
		shared a network it will produce a withdraw of the network after a delay 
		time described by |withdraw_dist|
    \item reannouncement: |[True/False]| variable, if true a node that previusly 
		withdrawed a route will schedule a reannouncement of the route 
		using the distribution described in |reannouncement_dist|
    \item withdraw\_dist: Variable that describe a withdraw distribution, 
		for a distributions explanation please see \Cref{subsec:distribution}
    \item reannouncement\_dist: Like the withdraw distribution but for reannouncements
    \item datarate: |{distribution}| Time required to start the actual 
		transmission of a message after the scheduling
    \item processing: |{distribution}| Processing time of any information, 
		for example can be used after the reception of a packet to 
		simulate the processing of it
    \item delay: |{distrbution}| Network delay for the packets on links.
\end{itemize}

All parameters can be array of parameters, so is possible to run different 
combinations of them.
An array of parameters could be the following:
|seed: [0, 1, 2, 3]| -> this defines multiple seeds that can be used

\begin{lstlisting}[language=bash]
	"withdraw_dist": [{"distribution": "unif", "min": 5, "max": 10, "int": 0.1}, 
					  {"distribution": "unif", "min": 8, "max": 10, "int": 0.1}, 
					  {"distribution": "unif", "min": 2, "max": 3, "int": 0.1}]
\end{lstlisting}

An example of compleate json file:
\renewcommand{\lstlistingname}{Conf file}
\begin{lstlisting}[language=bash, caption=Example of json file, label=json:line_example]
	{                                                                               
	    "line" : {                                                                  
	        // seed(s) to initialize PRNGs                                          
	        "seed" : [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],                                
	        // duration of each simulation in seconds                               
	        "duration" : 60000,                                                     
	        // Graph file to simulate                                               
	        "graph": "graphs/tests/line.graphml",    
	        // log file name using configuration parameters, use {seed} or {date-time}
	        "output" : "results/line/line_{seed}.csv",
	        // Verbose value                                                        
	        "verbose": "True",                                                      
	        // Signaling flag                                                       
	        "signaling": "True",                                                    
	        // Signaling sequence, ignored if signaling false                       
	        "signaling_sequence": "AWAWAWA",                                        
	        // Implicit withdraw of routes                                          
	        "implicit_withdraw": "True",                                            
	        // Withdraw signaling                                                   
	        "withdraw": "True",                                                     
	        // Reannouncement of a destination after a withdraw                     
	        "reannouncement": "False",                                              
	        // Withdraw interval distribution from the announcement                 
	        "withdraw_dist": {"distribution": "const", "mean": 300},                
	        // announcement interval distribution from the withdraw                 
	        "reannouncement_dist": {"distribution": "const", "mean": 300},          
	        // Transmission time required to start the actual message transmission  
	        "datarate": {"distribution": "exp", "lambda" : 100},                    
	        // Processing time distribution                                         
	        "processing": {"distribution": "const", "mean": 0.00001},               
	        // Network delay distribution                                           
	        "delay": {"distribution": "unif", "min": 0.012, "max": 3, "int": 0.001} 
	    }                                                                           
	}   
\end{lstlisting}
In Conf file \ref{json:line_example} is possible to see that the the only vector
parameter is the |seed|.
The results of the simulations will be saved using the path given in the |output|
command, plus substituting the seed used in the csv file name.
the results folder is mandatory, it must already exists, while all the other 
folders will be created on the fly by the software.
From the signaling parameter is also possible to notice that this is a signaling
experiment, this means that the nodes that contains at least one destination will
only transmit messages respecting the given sequence.

\subsection{Distributions}
\label{subsec:distribution}

Up to now the possible distributions that can be itroduced in the environment are the following:

\begin{itemize}
    \item Uniform: a uniform distribution will have like name unif and 3 parameters 
		min that represent the minimum value that can be choose max the maximum 
		value int that represent the precision used for all the values between 
		min and max, all parameters can be float values
    \item Exponential: an exponential distribution have like name exp and it has 
		a parameter lambda, like for the uniform distribution the parameter can 
		be a float value
    \item Constant: a constant distribution have like name: const and it has one 
		parameter named mean
\end{itemize}

All the values of the distributions are intended in seconds.

An example of distribution: |{"distribution": "const", "mean" : 0.00001}|

Distributions used in the graph to override the standard delay:
\begin{lstlisting}[language=bash]
 <edge source="0" target="1">
     <data key="d1">{"distribution": "unif", "min": 1, "max": 5, "int": 0.01}</data>
 </edge>
\end{lstlisting}

\subsection{Policies}
\label{subsec:policies}

A policy function is applied like exporter filter. If the value returned by the 
function is not infinite the route will be sent with the value returned by f

policy functions are formally explained in \fixme{insert citation} Sec IV-c

An example of policy function could be this: |<1, inf, inf>|

This policy can simulate the peer behaviour of a node. It can send only routes 
that have a policy level of 0 and will substitute to the route the policy level 
with 1 before the actual transmission.

In the graphml file is mandatory to not use |<| and |>| simbols, so a function can 
be easily defined with:

|2, 2, 2|

Rotues that are originated by nodes will receive a policy level of \num{0} automatically.

Policy function used in a graphml file on an edge to define the relationship
between nodes:
\begin{lstlisting}[language=bash]
  <edge source="5" target="2">
      <data key="d2">0, inf, inf</data>
  </edge>
  <edge source="2" target="5">
      <data key="d2">2, 2, 2</data>
  </edge>
\end{lstlisting}

\subsection{RFD}
\label{subsec:RFD}

Refers to \fixme{insert citation} for a deep explanation about \ac{RFD} and its
parameters.

The \ac{RFD} system of a node is composed by multiple parameters:
\begin{itemize}
		\item Withdraw penalty: penalty applied to the figure of merit in case 
			of a withdraw reception
		\item Re-announcement penalty: penalty applied to the figure of merit
			in case of a re-announcement
		\item Attribute change penalty: penalty applied to the figure of merit
			in case of an attribute change.
		\item Suppression threshold (cut): threshold after which a route is 
			suppressed
		\item Reuse threshold: threshold after which a route is usable again
		\item T-hold timer: maximum time that a route could be suppressed
		\item Decay ok: decay time used if the route is reachable, half-life time
		\item Decay ng: decay time used if the route is not reachable, half-life time
		\item Decay memory limit ok: max time for which the memory of the figure
			of merit is kept if the route is reachable
		\item Decay memory limit ng: max time for which the memory of the figure
			of merit is kept if the route is not reachable;
		\item delta-t: time granularity in seconds used to perform all decay computations.
\end{itemize}	

An \ac{RFD} configuration is composed by all this attributes one after the other
in the same line separated by a "|,|".
The |rfd_setter.py| can be used to set an \ac{RFD} configuration for each node in 
a graph, is described in \Cref{sec:graph_generator}.

An example of \ac{RFD} configuration is the following:
\begin{lstlisting}[language=bash]
	1.0, 0.0, 0.5, 2.0, 0.75, 3600, 900, 900, 3600, 3600, 5
\end{lstlisting}

An example of \ac{RFD} configuration in a graphml file:
\begin{lstlisting}[language=bash]
	<node id="0">
	  <data key="d0">1.0, 0.0, 0.5, 2.0, 0.75, 3600, 900, 900, 3600, 3600, 5</data>
	</node> 
\end{lstlisting}

\section{Discrete event simulations}
\label{sec:des}

The simulator is the main component of the project, it permits to execute
experiments with different environments with the predefined topology.

\begin{figure}[h]
	\begin{center}
		\begin{tikzpicture}[scale=0.2]
			\tikzstyle{every node}+=[inner sep=0pt]
			\draw [black] (0,0) circle (4);
			\draw [black] (14,0) circle (4);
			\draw [black] (24,-2.5) rectangle (38,2.5);
			\draw [black] (48,0) circle (4); 
			\draw [thick, ->] (4,0) -- (10,0);
			\draw [thick, ->] (18,0) -- (24,0);
			\draw [thick, ->] (38,0) -- (44,0);
			\node [Graphml] at (0,0) {Graphml};
			\node [Json] at (14,0) {json};
			\node [DES] at (31,0) {DES};
			\node [Output] at (48,0) {Output};
		\end{tikzpicture}
	\end{center}
	\caption{Discrete event simulator structure}
	\label{fig:des_structure}
\end{figure}

The \ac{DES} receives as input a json file with all the environment parameters
that will be used during the experiment.
The output of the experiment could be divided in two category:
\begin{itemize}
	\item Standard output: The simulator will print messages on the standard
		output if the verbose option of the configuration file is active
	\item CSV files: the simulator will save events on the csv file
		configured as output in the json file.
\end{itemize}

The CSV file is mandatory, so the simulator will at least print the events 
sequence on that file.

The python file that act as entry point for the simulator is |src/fsm.py|.

\subsection{Simulator arguments}
\label{subsec:des_param}

The command:

\begin{lstlisting}[language=bash]
	python3 fsm.py --help
\end{lstlisting}

If an error message of a missing library is displayed, rembember to source the 
environment using |source env/bin/activate| before using the software of 
the repository.
Inside the folder |src/json/examples| there are some json examples that I will use
now to explain the different arguments that the simulator requires.

We will look to the file |line.json|.
If you open the file you can notice that the file is composed by two json parts.
The first one has as name |simulation| the second one |line|.

\begin{lstlisting}[language=bash]
{
	"simulation" : {
		....
	},
	"line" : {
		....
	}
}
\end{lstlisting}

Now we will take a look to the argument |-l| or |--list|, this argument has
the function to list all the available simulations in the standard output.

Try to run:
\begin{lstlisting}[language=bash]
	python3 fsm.py -c json/examples/line.json -l
\end{lstlisting}

The |-c| attribute is mandatory and defines which json file should be used by the
simulator.

The output should be:
\begin{lstlisting}[language=bash]
./fsm.py -c json/tests/line.json -s simulation -r 0
./fsm.py -c json/tests/line.json -s simulation -r 1	
\end{lstlisting}

This command has not executed the simulation, but it gives us some information
about the environment.
As default, if not specified the simulator will use the environment named 
simulation.
So it has looked into the json file, it has found the |simulation| environment
and it has gives us the list of different runs that we can execute with that
environment.

As you have probably imanginated up to now the parameter |-s| can be used
to pass the environment that we want to use in the simulation.
Infact if we use the following command we will obtain the same output as before:

\begin{lstlisting}[language=bash]
	python3 fsm.py -c json/examples/line.json -s simulation -l
\end{lstlisting}

The simulator has retrieved two lines, the first one endup with |-r 0| and the
second one with |-r 1|.
Thats because in the |simulation| environment we have a single vector of two 
elements, that is the seed.
\begin{lstlisting}[language=bash]
{
	"simulation" : {
		"seed" : [0, 1],
		....
	},
	"line" : {
		....
	}
}
\end{lstlisting}
The simulator recognize that we can run two different runs with the |simulation|
environment and it gives us the option to decide wich one using the |-r| argument.
It will assign a number to each combination of parameters that we have in
the environment.

With one single vector is easy to know which one correspond to which run number.
but with a more complex one?
For this purpose comes in help the |-L| or |--LIST| argument.

The following command will gives us a lot of information about the parameters
of the environment that we are using and the combination of values.

\begin{lstlisting}[language=bash]
	python3 fsm.py -c json/examples/line.json -s simulation -L
\end{lstlisting}

The ouput is:
\begin{lstlisting}[language=bash]
./fsm.py -c json/tests/line.json -s simulation -r 0: seed: 0
./fsm.py -c json/tests/line.json -s simulation -r 1: seed: 1
\end{lstlisting}

Now we know that to the index of run 0 correspond the seed 0 and to the 
index 1 correspond the seed 1.

The last argument is a flag |-g| you will see the result of this flag in the next
chapter where is explained the first experiment.
This argument will disable the rendering of the graph at the end of the simulation
if instad you leave this function untouched in the output folder will be
present also a graph rendered using networkx in the output folder.

Now lets take a look to a more complex environment.
Instead of the simulation environment try the line one with the |-l| and |-L|
parameters you will see that with more parameters vectors you will have a lot 
more runs that are possible.
The number of runs is always equal to the number of possible combination of 
all the parameters.

\begin{lstlisting}[language=bash]
	python3 fsm.py -c json/examples/line.json -s line -l
	python3 fsm.py -c json/examples/line.json -s line -L
\end{lstlisting}

\subsection{First experiment}
\label{subsec:first_exp}

For the first experiment we will use the |src/json/examples/line.json| with the
|simulation| environment lets take a look at it.

\begin{lstlisting}[language=json]
	"simulation" : {
		// seed(s) to initialize RNGs
		"seed" : [0, 1],
		// duration of each simulation in seconds
		"duration" : 600,
		// Graph file to simulate
		"graph": "graphs/general_tests/simple_line.graphml",
		// log file name using configuration parameters, use {seed} or {date-time}
		"output" : "results/tests/line/line_{seed}.csv",
		// Verbose value
		"verbose": "True",
		// Signaling flag
		"signaling": "False",
		// Signaling sequence, ignored if signaling false
		"signaling_sequence": "",
		// Implicit withdraw of routes
		"implicit_withdraw": "True",
		// Withdraw signaling
		"withdraw": "True",
		// Reannouncement of a destination after a withdraw
		"reannouncement": "True",
		// Withdraw interval distribution from the announcement
		"withdraw_dist": {"distribution": "const", "mean": 300},
		// announcement interval distribution from the withdraw
		"reannouncement_dist": {"distribution": "const", "mean": 300},
		// Transmission time required to start the actual message transmission
		"datarate": {"distribution": "exp", "lambda" : 100},
		// Processing time distribution
		"processing": {"distribution": "const", "mean": 0.00001},
		// Network delay distribution
		"delay": {"distribution": "unif", "min": 0.012, "max": 3, "int": 0.001}
	}
\end{lstlisting}

The graph that will be used could be represente by \Cref{fig:simple_line}
\begin{figure}[h]
	\begin{center}
		\begin{tikzpicture}[scale=0.2]
			\tikzstyle{every node}+=[inner sep=0pt]
			\draw [black] (10.7,-26.5) circle (3);
			\draw (10.7,-26.5) node {$0$};
			\draw [black] (10.7,-26.5) circle (2.4);
			\draw [black] (21.6,-17.5) circle (3);
			\draw (21.6,-17.5) node {$0\_1$};
			\draw [black] (21.6,-34.2) circle (3);
			\draw (21.6,-34.2) node {$0\_2$};
			\draw [black] (33.1,-26.5) circle (3);
			\draw (33.1,-26.5) node {$1$};
			\draw [black] (46.8,-26.5) circle (3);
			\draw (46.8,-26.5) node {$2$};
			\draw [black] (13.01,-24.59) -- (19.29,-19.41);
			\fill [black] (19.29,-19.41) -- (18.35,-19.53) -- (18.99,-20.31);
			\draw [black] (13.15,-28.23) -- (19.15,-32.47);
			\fill [black] (19.15,-32.47) -- (18.78,-31.6) -- (18.21,-32.42);
			\draw [black] (23.96,-19.35) -- (30.74,-24.65);
			\fill [black] (30.74,-24.65) -- (30.42,-23.76) -- (29.8,-24.55);
			\draw [black] (24.09,-32.53) -- (30.61,-28.17);
			\fill [black] (30.61,-28.17) -- (29.66,-28.2) -- (30.22,-29.03);
			\draw [black] (36.1,-26.5) -- (43.8,-26.5);
			\fill [black] (43.8,-26.5) -- (43,-26) -- (43,-27);
		\end{tikzpicture}
	\end{center}
	\caption{Simple line graph}
	\label{fig:simple_line}
\end{figure}

Node $0$ has a double circle around it because it contains a destination that will
be shared.

The verbose option on the configuration file is active so we will see both
the outputs of the simulator.

Both Withdraw and reannounce option are active so the node 0 will continiusly
send withdraws and announcement of its destination, using the distributions defined
in the environment.

The simulation will endup when the max time will be reached.

To run our first experiment use:

\begin{lstlisting}[language=bash]
	python3 fsm.py -c json/examples/line.json -r 0
\end{lstlisting}

You will see that almost instantly the simulation will end because of the
small ammount of events.
I suggest to use the following command to save the standard output on a file
instead of the terminal.

\begin{lstlisting}[language=bash]
	python3 fsm.py -c json/examples/line.json -r 0 > line.log
\end{lstlisting}

Now you will see the standard output in the |log.tmp| file.
In the next chapter, \Cref{subsec:des_output} I will take a look to this 
output, and also the CSV output of this experiment.

\subsection{Output of the experiment}
\label{subsec:des_output}

We will now analyze the output of the run executed with the command:

\begin{lstlisting}[language=bash]
	python3 fsm.py -c json/examples/line.json -r 0 > line.log
\end{lstlisting}

\\
\textbf{STD output}
\\

The first ouptut that we will take a look is the standard output, the one that
has been saved on the file |line.log|.

Thanks to the option |verbose| active we will see a lot of information, but 
we can divide the entire file in three section.

The fist one is composed by the evolution of the environment, that is described
by all the events that happen.
All the line of tipe |time-node event| compose this category, as an example 
you can look to this extract of the |line.log| file:

\begin{lstlisting}[language=bash]
....
0.01865607111065223-0 Start TX packet: {'id': 1, 'type': 0, 'content': "{'addr': '10.0.0.0/24', 'nh': '0', 'path': ['0'], 'policy_value': '0'}"}
0.024113202566068158-0 End TX packet: {'id': 1, 'type': 0, 'content': "{'addr': '10.0.0.0/24', 'nh': '0', 'path': ['0'], 'policy_value': '0'}"}
0.8097564524414427-Lid:1 to 0_2 Transmitting msg: {'id': 1, 'type': 0, 'content': "{'addr': '10.0.0.0/24', 'nh': '0', 'path': ['0'], 'policy_value': '0'}"}
0.8097664524414426-0_2 Start packet reception
0.8169259999391142-0_2 End packet reception: {'id': 1, 'type': 0, 'content': "{'addr': '10.0.0.0/24', 'nh': '0', 'path': ['0'], 'policy_value': '0'}"}
0.8169359999391141-0_2 Start pkt evalution {'id': 1, 'type': 0, 'content': "{'addr': '10.0.0.0/24', 'nh': '0', 'path': ['0'], 'policy_value': '0'}"}
....
\end{lstlisting}

As you can see we can extract a lot of information from those lines, the transmission
of a packet from node $0$ to node $0\_2$ and also the reception of it.
For an explanation of all the possibile outputs please refers to \Cref{subsec:events}.
Is possible to see that we get also the link output, in this case the third line
represent that a link has took in charge a message for the node $0\_2$, links
are identified by a \ac{LID} and them are \textbf{FIFO}, this is important
because two messages on the same link will never reach the destination in 
a different respect to the on that they have been sent.
There could be different delays applied to different messages on the same
link, but the order will be always the same.

The second part on the standard output will be the node state at the end of 
the run, you will find this part at the end of the file, and you will see something
like that:

\begin{lstlisting}[language=bash]
....
Node: 1
Neighborhood: ['2']
Destinations queue: 
Routing Table:
BGP RIB handler: 
ADJ_RIB_in:
LOC_rib:
2 ADJ_RIB_out:
Withdraw List: []
....
\end{lstlisting}

This is a general description of the node $1$ and all the components that 
are in it.
You will see all the routing information, the \ac{RIB}, etc.
In this case the node doesn't have any information on how to reach the destination
this because near the end of the experiment it has received a withdraw of the
route that it has evaluated.

Try the experiment with the second run using the command:

\begin{lstlisting}[language=bash]
....
python3 fsm.py -c json/examples/line.json -r 1 > line.log
tail -n 30 line.log
....
\end{lstlisting}

You will see an interesting difference on the node $1$ withdraw list, and in the
node $2$ routing table, it has not yet received the route withdraw.

The last part of the standard output is represent by two lines that are always
printed also with the |verbose| option to false.

\begin{lstlisting}[language=bash]
Maximum simulation time reached. Terminating
Total simulation time: 0 hours, 0 minutes, 0 seconds
\end{lstlisting}

It simply tells how much time has take the experiment to reach the simulation limit
that in this case was \num{600}.

\\
\textbf{CSV Output}
\\

The second type of output that is produced by the simulator is the CSV file
that contains the list of events that happened during the run.

The CSV file will be saved accordingly with the |output| parameter of the
json environment file.
In this case the output parameter was:

\begin{lstlisting}[language=json]
"output" : "results/tests/line/line_{seed}.csv",
\end{lstlisting}

So we expect to find a CSV file inside the folder |results/tests/line/| with
a name composed by |line_| and the accordingly to the one we used.
If you have executed both the runs, with |-r 0|/|-r 1| you will find two file
in the folder.

The csv folder is composed as follow:
\begin{lstlisting}[language=json]
event_id|event_cause|event|time|node|value
2|0|6|1e-05|0|{0}
6|1|11|3.0000000000000004e-05|0|0_1
7|1|11|3.0000000000000004e-05|0|0_2
8|6|15|4e-05|0|{'id': 0, 'type': 0, 'content': "{'addr': '10.0.0.0/24', 'nh': '0', 'path': ['0'], 'policy_value': '0'}"}
10|6|1|0.01864607111065223|0|{'id': 0, 'type': 0, 'content': "{'addr': '10.0.0.0/24', 'nh': '0', 'path': ['0'], 'policy_value': '0'}"}
9|7|15|0.01865607111065223|0|{'id': 1, 'type': 0, 'content': "{'addr': '10.0.0.0/24', 'nh': '0', 'path': ['0'], 'policy_value': '0'}"}
12|7|1|0.024113202566068158|0|{'id': 1, 'type': 0, 'content': "{'addr': '10.0.0.0/24', 'nh': '0', 'path': ['0'], 'policy_value': '0'}"}
14|12|2|0.8169259999391142|0_2|{'id': 1, 'type': 0, 'content': "{'addr': '10.0.0.0/24', 'nh': '0', 'path': ['0'], 'policy_value': '0'}"}
17|14|6|0.8169459999391141|0_2|{1}
\end{lstlisting}

\begin{itemize}
	\item \textbf{event\_id} represents the id of the event that has been registered
	\item \textbf{event\_cause} is the id of the event that has caused this one, is possible
		that an event\_cause refers to an event that has not been registered
	\item \textbf{event} this is the code identifier of the event, you can find
		the list of possible events in \Cref{subsec:events}
	\item \textbf{time} this value represent the instant in which the event
		happened
	\item \textbf{node} identifier of the node that triggered the event
	\item \textbf{value} String that represent something valuable for the event,
		for a message could be the content, etc.
\end{itemize}

This file can be used to study the evolution of the experiments with scripts.
The \Cref{subsec:events} also explain for each event what will be printed
if logged in the csv file.

\subsection{Events}
\label{subsec:events}

\begin{longtable}[c]{| p{5.5cm} | p{1.5cm} | p{4cm} | p{4cm} |}

 \hline
 \multicolumn{4}{| c |}{Events Table}\\
 \hline
 Event name & Event id & Event csv value & Event description\\
 \hline
 \endfirsthead

 \hline
 \multicolumn{4}{|c|}{Continuation of the Events table}\\
 \hline
 Event name & Event id & Event csv value & Event description\\
 \hline
 \endhead

 \hline
 \endlastfoot

 TX & 1 & |str(packet_transmitted)| & This event denote the end of a transmission
	of a packet on a link\\
 RX & 2 & |str(packet_received)| & This event denote the end of a packet reception,
	the reception of a packet ends when it is passed to the packet evaluator\\
 RT\_CHANGE & 3 & Not represented in the CSV & This event represent a change in the 
	routing table (obsolete, not used)\\
 NEW\_PATH & 4 & Not represented in the CSV & This event represent a path 
	change (obsolete, not used)\\
 REANNOUNCE & 5 & Not represented in the CSV & This event is used to trigger
	a route reannounce in the simulator\\
 RIB\_CHANGE & 6 & |set| of the known routes hash & This event is used when
	there is a change in the \ac{RIB}, a new route or the removal of a known route\\
 DST\_ADD & 7 & Not represented in the CSV & This event is triggered when there
	is a new destination to add to the node, used at the boot of the network\\
 UPDATE\_SEND\_PROCESS & 8 & Not represented in the CSV & This event is triggered
	when at the end of a packet evaluation has been decided the new updates that
	must be sent to neighbours and the variations on the LOC\_rib, RIB\_out caused
	by the message\\
 INTRODUCE\_NETWORKS & 9 & Not represented in the CSV & Event triggered when
	a new Network must be introduced, added at the \ac{RIB}, it triggers the correct
	function handler \\
 REMOVE\_NETWORKS & 10 & Not represented in the CSV & Event triggerd when a 
	network must be removed, removed from the \ac{RIB}, it triggers the correct
	function handler \\
 MRAI & 11 & |str(neighbour_id)| & This event is trigered when an \ac{MRAI} cicle/evaluation
	is concluded\\
 START\_RX & 12 & Not represented in the CSV & This event is triggered at the
	beggining of a reception and schedule the end of the reception \\
 START\_PKT\_EVAL & 13 & Not represented in the CSV & Event used to trigger 
	the beggining of a packet evaluation, this process will evaluate the packet
	before the introduction in the \ac{RIB} \\
 END\_PKT\_EVAL & 14 & Not represented in the CSV & Event triggered when 
	the evaluation of a packet is ended and the data has been sent to the \ac{RIB}
	or ignored\\
 START\_TX & 15 & |str(packet_to_transmit)| & This event represent the beginning
	of a transmission\\
 START\_UPDATE\_SEND\_PROCESS & 16 & Not represented in the CSV & This event 
	represent the beginning of the process that evaluates the ADJ\_RIB\_in in order
	to introduce/update netowrks\\
 ROUTE\_REUSABLE & 17 & |str(route)| & This event triggers the 
	function handler that will make a route usable again, afterh it has 
	been suppressed by the \ac{RFD} \\
 END\_T\_HOLD & 18 & |str(route)| & This event is used to trigger
	the function handler that makes a route usable again after it has been suppressed
	for T-hold time\\
 FIGURE\_OF\_MERIT\_VARIATION & 19 & |str((route, figure-of-merit))|& This event
	denotes a cShange in the figure of merit of a route, it is used for every
	change, caused by new messages or a route reusable event, etc.\\
 ROUTE\_SUPPRESSED & 20 & |str(route)| & Event triggere when a route has been
	suppressed because the figure of merit passed the suppression threshold\\
 \hline	
 \caption{Events list\label{tbl:events}}\\
\end{longtable}

\Cref{tbl:events} gives a rough view of all the events that are used/triggerd 
during the simulations and the meaning of them.
Also in the table is possible to see the representation of them in the CSV output
file and the associated value.

I think that is also important to point out how are represented routes and packets.
For example the following is a string that represent the dictionary used 
for routes:
\begin{lstlisting}[language=bash]
{'addr': '10.0.0.0/24', 'nh': '1', 'path': ['1', '0_1', '0'], 'policy_value': '0'}
\end{lstlisting}
This string represent the destination |10.0.0.0/24| reached through the path |['1', '0_1', '0']|
using as \ac{NH} the node $1$, the policy value associated with the route is $0$
and it is used to evaluate through wich neighbour the network must be sent.

A message is represented like it follows:
\begin{lstlisting}[language=bash]
{'id': 5, 'type': 0, 'content': "{'addr': '10.0.0.0/24', 'nh': '1', 'path': ['1', '0_1', '0'], 'policy_value': '0'}"}
\end{lstlisting}
The id of a message is unique for each message transmitted, the type determine if it
is an advertisement or a withdraw, respecively \num{0}/\num{1}, and then 
the content represent what is transmitted (|str(content)|)

\section{Analyzer}
\label{sec:analyzer}

The analyzer is the part of the toolchain that takes as input the CSV output of
the simulator and retrieves other CSVs that depends on the parameters that has
been passed to it.
Is possible to analyze in general the network evolution with multiple runs.
Is possible to study how the network reacts to a specific signal.
Is also possible to sudy how a specific node reacts during the network evolution.
The analyzer can also plot some graphs or studies, but the main purpose of it 
is to produce small CSVs that groups features that you want to study.

\subsection{Analyzer parameters}
\label{subsec:anal_param}

using the command:
\begin{lstlisting}[language=bash]
python3 analyzer.py --help
\end{lstlisting}
You will see the list of possible arguments that can be passed to the analyzer
some of them can coexists on the same command, others can't.
I will now explain every parameters with some details about it, in the next
sections (\Cref{subsec:anal_exec,subsec:anal_output}) will also be showed some
usage of them and the results.

The mandatory arguments are:
\begin{itemize}
	\item |-f/--file|, this argument define the file/s that the analyzer
		should take as input, multiple files can be passed
	\item |-o/--output| This argument defines where the output should
		be placed, is possible also to give a special name that will be used,
		for example |folder/folder/out_5| all the output files will be saved
		using this path and all the files names will begin with |out_5|
\end{itemize}

The optional paramers are:
\begin{itemize}
	\item |-n/--node| defines which nodes should be studied, is possible
		to use a subset of them |1 2 3| or study them all with the |all| tag
	\item |-r/--render| tag that activate the render function, the analyzer
		will automatically produce some plots, all of them are explained in the
		\Cref{subsec:anal_exec}
	\item |-d/--display| tag used to automatically display the \ac{FSM}
		graph at the end of the analysis
	\item |-S/--security| used to enable security checks, to avoid
		overwriting already existing result files
	\item |-t/--time| used to display the time required by the analyzer
		to execute different sections of the study
	\item |-v/--verbose| used to eneable the verbose mode
	\item |-p/--progress| used to disable the progress bar
	\item |-pi/--pickle| used to save in the output folder also the pickle
		format of the results, if enable ti will also look for the pickle
		file at the beginning of the anlysis to use them
	\item |-s/--signaling| used to analyze experiments that use specific
		signals instead of the random evolution
	\item |-F/--fsm| tag used to disable the \ac{FSM} study of the nodes
	\item |--rfd/--RFD| used to study the \ac{RFD} evolution of the runs
\end{itemize}

\subsection{Analyzer execution}
\label{subsec:anal_exec}

\subsection{Analyzer output}
\label{subsec:anal_output}

\section{First signaling experiment}
\label{sec:signaling_experiment}

\section{Plot results}
\label{sec:plot_results}

\section{Graph generator}
\label{sec:graph_generator}

\subsection{Property generators}
\label{sec:graph_propery_generators}

\section{Multiple experiments in parallel}
\label{sec:multiple_experiments}

\subsection{Parallel experiments examples}
\label{subsec:parallel_examples}

\section{Parallel experiments with multiple MRAIs}
\label{sec:parallel_mrais}

\subsection{Different MRAIs}
\label{subsec:MRAI_types}

\section{Examples}
\label{sec:examples}

\subsection{Line}
\label{subsec:ex_line}

\subsection{Line with delays}
\label{subsec:ex_line_delay}

\subsection{Line signaling}
\label{subsec:ex_line_signaling}

\subsection{Simple graph with MRAI}
\label{subsec:simple_graph_with_MRAI}

\subsection{Clique MRAI evolution}
\label{subsec:clique_evolution}

\subsection{Clique with RFD}
\label{subsec:clique_rfd}

\subsection{Clique different MRAIs comparison}
\label{subsec:clique_different_mrais}

\subsection{Small Internet graph}
\label{subsec:small_internet_graph}

\subsection{Small Internet graph with different MRAIs strategies}
\label{subsec:small_internet_graph_multiple_MRAIs}

\printindex
\bibliographystyle{IEEEtran}
\bibliography{references}

\end{document}
